#!/bin/zsh

# Function for the title subcommand
title_subcommand() {
    local padding=2
    local width=$((COLUMNS - padding * 2))

    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--padding)
                padding="$2"
                width=$((COLUMNS - padding * 2))
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local message="$*"
    local box_width=$((width - $padding))  # Subtract 2 for left and right box borders

    printf "\n%*s╭%s╮\n" $padding "" "$(printf '─%.0s' $(seq 1 $box_width))"

    echo "$message" | fold -s -w $box_width | while read line; do
        local line_padding=$(( (box_width - ${#line}) / 2 ))
        printf "%*s│%*s%s%*s│\n" $padding "" $line_padding "" "$line" $(( box_width - ${#line} - line_padding )) ""
    done

    printf "%*s╰%s╯\n" $padding "" "$(printf '─%.0s' $(seq 1 $box_width))"
}

# Function for the subtitle subcommand
subtitle_subcommand() {
    local padding=4  # Default padding for subtitle is 4
    local width=$((COLUMNS - padding * 2))
    local min_dashes=3  # Minimum number of dashes on each side

    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--padding)
                padding="$2"
                width=$((COLUMNS - padding * 2))
                shift 2
                ;;
            *)
                break
                ;;
        esac
    done

    local message="$*"
    local max_text_width=$((width - (3 + $padding) * min_dashes - (3 + $padding)))  # 2 for spaces around text
    local first_line=true

    echo "$message" | fold -s -w $max_text_width | while read line; do
        local text_width=${#line}
        local available_dash_space=$((width - text_width - 2))
        local left_dashes=$(( available_dash_space / 2 ))
        local right_dashes=$(( available_dash_space - left_dashes ))

        if $first_line; then
            right_dashes=$((right_dashes + 2))
            left_dashes=$((left_dashes - 2))
            first_line=false
        fi

        printf "\n%*s%s %s %s" $padding "" "$(printf '%*s' $left_dashes | tr ' ' '-')" "$line" "$(printf '%*s' $right_dashes | tr ' ' '-')"
    done
    printf "\n"
}

# Function for the run subcommand
run_subcommand() {
    local padding=6  # Default padding for run is 6
    local width=$((COLUMNS - padding * 2))
    local separator=""
    local command=""

    while [[ $# -gt 0 ]]; do
        case $1 in
            -p|--padding)
                padding="$2"
                width=$((COLUMNS - padding * 2))
                shift 2
                ;;
            -w|--width)
                width="$2"
                shift 2
                ;;
            -s|--separator)
                separator="$2"
                shift 2
                ;;
            --)
                shift
                command="$@"
                break
                ;;
            *)
                echo "Unknown option: $1"
                print_usage
                exit 1
                ;;
        esac
    done

    if [ -z "$command" ]; then
        echo "Error: No command provided."
        print_usage
        exit 1
    fi

    # Run the command and capture its output
    output=$(eval "$command")

    # Add padding and word wrap
    echo "$output" | fold -s -w $width | sed "s/^/$(printf '%*s' $padding)/"

    if [ -n "$separator" ]; then
        border=$(printf '%*s' $COLUMNS | tr ' ' "$separator")
        echo "$border"
    fi
}

# Main script logic
if [ $# -eq 0 ]; then
    print_usage
    exit 1
fi

subcommand="$1"
shift

case "$subcommand" in
    run)
        run_subcommand "$@"
        ;;
    title)
        title_subcommand "$@"
        ;;
    subtitle)
        subtitle_subcommand "$@"
        ;;
    *)
        echo "Unknown subcommand: $subcommand"
        print_usage
        exit 1
        ;;
esac
