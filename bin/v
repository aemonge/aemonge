#!/bin/zsh

VERSION="0.0.1"

function get_project_root() {
    local dir=$(readlink -f "${1:-$PWD}")
    while [[ "$dir" != "/" ]]; do
        if [[ -f "$dir/mise.toml" || -d "$dir/.git" || -f "$dir/package.json" || -f "$dir/pyproject.toml" || -f "$dir/Cargo.toml" ]]; then
            echo "$dir"
            return 0
        fi
        dir="$(dirname "$dir")"
    done
    return 1
}

function load_project_env() {
    local target_path="${1:-$PWD}"
    local project_root=$(get_project_root "$target_path")

    if [[ -n "$project_root" ]]; then
        export HOOKIE_PROJECT_ROOT="$project_root"
        export HOOKIE_CURRENT_PROJECT="${project_root:t}"
        if command -v mise &>/dev/null; then
            eval "$(mise hook-env -s zsh)"
        fi
    else
        unset HOOKIE_PROJECT_ROOT
        unset HOOKIE_CURRENT_PROJECT
    fi
}

function cmd_load_project() {
    local target_path="${1:-$PWD}"
    local project_root=$(get_project_root "$target_path")

    # Optimization: Only output or update if project changed or forced
    if [[ -n "$project_root" ]]; then
        local project_name="${project_root:t}"
        
        # Inside Neovim: Just update host Neovim context silently
        if [ -n "$NVIM" ]; then
            nvr -c "let \$HOOKIE_PROJECT_ROOT = '$project_root'" \
                -c "let \$HOOKIE_CURRENT_PROJECT = '$project_name'" \
                -c "lua if package.loaded.lualine then require('lualine').refresh() end" > /dev/null 2>&1
            return
        fi

        # Outside Neovim: Output exports
        # We always output if we are in a project to ensure mise stays in sync
        # unless you really want to skip it for speed. 
        # But 'cd project_path ain't working' might be due to over-optimization.
        echo "export HOOKIE_PROJECT_ROOT=\"$project_root\""
        echo "export HOOKIE_CURRENT_PROJECT=\"$project_name\""
        
        if command -v mise &>/dev/null; then
             mise hook-env -s zsh
        fi
    else
        # No project found: Clean up
        if [[ -n "$HOOKIE_PROJECT_ROOT" ]]; then
            echo "unset HOOKIE_PROJECT_ROOT"
            echo "unset HOOKIE_CURRENT_PROJECT"
            # Optional: deactivate venv etc? 
            # mise hook-env usually handles unsetting its own vars
            if command -v mise &>/dev/null; then
                 mise hook-env -s zsh
            fi
        fi
    fi
}

function show_help() {
    echo "v - Versatile Neovim wrapper script with term-multiplier powers using neovim-remote"
    echo ""
    echo "  This script provides a convenient interface for various Neovim operations,"
    echo "  including changing directories, opening files in split views, clearing the"
    echo "  terminal, managing sessions, and more. It's designed to work seamlessly"
    echo "  with both Neovim and terminal environments."
    echo ""
    echo "Usage: v [SUBCOMMAND] [ARGS]"
    echo ""
    echo "  Subcommands:"
    echo "    split           Open file in split view"
    echo "    hover           Open file in hover view"
    echo "    isplit          Open file in split view (inverted)"
    echo "    waits           Open file for quick editing (auto-closes buffer)"
    echo "    spliting        Combine split and waits"
    echo "    bg              Open file in background tab in Neovim"
    echo "    save            Using sessions.nvim save the current session"
    echo "    restore         Using sessions.nvim restore the last session"
    echo "    cd              Change directory in Neovim"
    echo "    clear           Clear terminal in Neovim"
    echo "    venv            Call the nvim set venv to change  env in current v session"
    echo "    reset_venv      Call the nvim set reset the current  venv"
    echo "    completions     Generate zsh completions for this script"
    echo "    [no subcommand] Open file in Neovim or create a session if first argument is a directory"
    echo ""
    echo "Options:"
    echo "  -h, --help      Show this help message and exit"
    echo "  -v, --version   Show version information and exit"
}

function show_version() {
    echo "v version $VERSION"
}

function completions() {
    local completions_file="$HOME/.zfunc/_v"
    mkdir -p "$HOME/.zfunc"

    echo "#compdef v" > "$completions_file"
    echo "" >> "$completions_file"
    echo "_v() {" >> "$completions_file"
    echo "  local -a commands" >> "$completions_file"
    echo "  commands=(" >> "$completions_file"
    echo "    'split'" >> "$completions_file"
    echo "    'hover'" >> "$completions_file"
    echo "    'isplit'" >> "$completions_file"
    echo "    'waits'" >> "$completions_file"
    echo "    'spliting'" >> "$completions_file"
    echo "    'bg'" >> "$completions_file"
    echo "    'save'" >> "$completions_file"
    echo "    'restore'" >> "$completions_file"
    echo "    'cd'" >> "$completions_file"
    echo "    'clear'" >> "$completions_file"
    echo "    'venv'" >> "$completions_file"
    echo "    'reset_venv'" >> "$completions_file"
    echo "    'completions'" >> "$completions_file"
    echo "  )" >> "$completions_file"
    echo "" >> "$completions_file"
    echo "  _arguments -C \\" >> "$completions_file"
    echo "    '(-h --help)'{-h,--help}'[Show help message]' \\" >> "$completions_file"
    echo "    '(-v --version)'{-v,--version}'[Show version information]' \\" >> "$completions_file"
    echo "    '1: :->first_arg' \\" >> "$completions_file"
    echo "    '*: :->args'" >> "$completions_file"
    echo "" >> "$completions_file"
    echo "  case \$state in" >> "$completions_file"
    echo "    first_arg)" >> "$completions_file"
    echo "      _alternative \\" >> "$completions_file"
    echo "        'commands:command:(\${commands[@]})' \\" >> "$completions_file"
    echo "        'files:file:_files'" >> "$completions_file"
    echo "      ;;" >> "$completions_file"
    echo "    args)" >> "$completions_file"
    echo "      case \$words[1] in" >> "$completions_file"
    echo "        cd)" >> "$completions_file"
    echo "          _directories" >> "$completions_file"
    echo "          ;;" >> "$completions_file"
    echo "        isplit|split|hover|waits|spliting|bg)" >> "$completions_file"
    echo "          _files" >> "$completions_file"
    echo "          ;;" >> "$completions_file"
    echo "        clear|save|restore|venv|reset_venv)" >> "$completions_file"
    echo "          # No further arguments for these commands" >> "$completions_file"
    echo "          ;;" >> "$completions_file"
    echo "        *)" >> "$completions_file"
    echo "          _files" >> "$completions_file"
    echo "          ;;" >> "$completions_file"
    echo "      esac" >> "$completions_file"
    echo "      ;;" >> "$completions_file"
    echo "  esac" >> "$completions_file"
    echo "}" >> "$completions_file"
    echo "" >> "$completions_file"
    echo "_v \"\$@\"" >> "$completions_file"

    echo "Completions for 'v' script have been generated and stored in $completions_file"
    echo "Please add the following line to your .zshrc if it's not already there:"
    echo "  fpath=(~/.zfunc \$fpath)"
    echo "Then restart your shell or run 'source ~/.zshrc'"
}

function isvim() {
    cols=$(tput cols)
    lines=$(tput lines)
    adjusted_height=$((lines * 19 ))
    adjusted_width=$((cols * 7))
    split_command="leftabove split"

    if [ "$adjusted_width" -gt "$adjusted_height" ]; then
        split_command="leftabove vsplit"
    fi

    if [[ "$OSTYPE" == "darwin"* ]]; then
        nvr -cc "$split_command $(greadlink -f "$@")"
    else
        nvr -cc "$split_command $(readlink -f "$@")"
    fi
}

function hover_vim() {
    # 1. Check if running inside a Neovim terminal
    if [ -z "$NVIM" ]; then
        echo "Please start a v session: 'v .'"
        return 1
    fi

    local target_file
    # Resolve absolute path (handles macOS/Linux differences)
    if [[ "$OSTYPE" == "darwin"* ]]; then
        target_file=$(greadlink -f "$1")
    else
        target_file=$(readlink -f "$1")
    fi

    # 2. Build Lua command using Bash array syntax
    local lua_lines=(
        "local buf = vim.fn.bufadd('${target_file}')"
        'local width = math.floor(vim.o.columns * 0.8)'
        'local height = math.floor(vim.o.lines * 0.7)'
        'local row = math.floor((vim.o.lines - 2 - height) / 2)'
        'local col = math.floor((vim.o.columns - width) / 2)'
        "local opts = { relative = 'editor', width = width, height = height, row = row, col = col, style = 'minimal', border = 'rounded' }"
        "vim.api.nvim_open_win(buf, true, opts)"
    )

    # Flatten the array into a single string with spaces
    # Prepend 'lua ' so Neovim executes it as Lua
    local lua_cmd="lua ${lua_lines[*]}"

    # Send the command to the remote Neovim instance
    nvr -c "$lua_cmd"
}

function svim() {
    cols=$(tput cols)
    lines=$(tput lines)
    adjusted_height=$((lines * 19 ))
    adjusted_width=$((cols * 7))
    split_command="split"

    if [ "$adjusted_width" -gt "$adjusted_height" ]; then
        split_command="vsplit"
    fi

    if [[ "$OSTYPE" == "darwin"* ]]; then
        nvr -cc "$split_command $(greadlink -f "$@")"
    else
        nvr -cc "$split_command $(readlink -f "$@")"
    fi
}

function background() {
    if [ -z "$NVIM" ]; then
        echo "Please start a v session: 'v .'"
        return 1
    fi

    files=()
    count=0
    for file in "$@"; do
        # Get the full path of the file, using readlink with fallback to realpath
        full_path=$(readlink -f "$file" 2>/dev/null || realpath -m "$file")

        # Extract the directory path
        dir_path=$(dirname "$full_path")

        # Create the directory if it doesn't exist
        mkdir -p "$dir_path"

        # Add the file to the array
        files+=("$full_path")
        ((count++))
    done

    if [ ${#files[@]} -gt 0 ]; then
        # Open all files in new tabs
        nvr --remote-tab-silent "${files[@]}"

        # Move back to the original tab
        if [ $count -gt 0 ]; then
            nvr -c "${count}tabp"
        fi
    else
        echo "No files specified."
        return 1
    fi
}

function spliting() {
    # quickedit_split
    local _readlink
    local _opener

    if [[ "$OSTYPE" == "darwin"* ]]; then
        _readlink="greadlink"
    else
        _readlink="readlink"
    fi

    cols=$(tput cols)
    lines=$(tput lines)
    adjusted_height=$((lines * 19 ))
    adjusted_width=$((cols * 7))
    split_command="split"
    if [ "$adjusted_width" -gt "$adjusted_height" ]; then
        split_command="vsplit"
    fi
    # split_command="split"  # Just split by default

    if type nvr > /dev/null && [ -n "$NVIM" ]; then
        # _opener=(nvr -c "setlocal bufhidden=wipe" --remote-tab-wait )
        _opener=(
            nvr
            -c "setlocal bufhidden=wipe"
            -c "startinsert!"
            -cc $split_command
            --remote-wait-silent
        )
    else
        _opener=(nvim)
    fi

    files=()
    for file in "$@"; do
        # Get the full path of the file, using readlink with fallback to realpath
        full_path=$(readlink -f "$file" 2>/dev/null || realpath -m "$file")

        # Extract the directory path
        dir_path=$(dirname "$full_path")

        # Create the directory if it doesn't exist
        mkdir -p "$dir_path"

        # Add the file to the array
        files+=("$full_path")
    done

    # Then, open all files at once
    "${_opener[@]}" "${files[@]}"
}

function waits() {
    local _readlink
    local _opener

    if [[ "$OSTYPE" == "darwin"* ]]; then
        _readlink="greadlink"
    else
        _readlink="readlink"
    fi

    if type nvr > /dev/null && [ -n "$NVIM" ]; then
        _opener=(
            nvr
            -c "setlocal bufhidden=wipe"
            --remote-tab-wait
        )

    else
        _opener=(nvim)
    fi

    files=()
    for file in "$@"; do
        # Get the full path of the file, using readlink with fallback to realpath
        full_path=$(readlink -f "$file" 2>/dev/null || realpath -m "$file")

        # Extract the directory path
        dir_path=$(dirname "$full_path")

        # Create the directory if it doesn't exist
        mkdir -p "$dir_path"

        # Add the file to the array
        files+=("$full_path")
    done

    # Then, open all files at once
    "${_opener[@]}" "${files[@]}"
}

function vim_func() {
    local _opener

    if [ -n "$NVIM" ]; then
        _opener=(nvr --remote-tab)
    else
        _opener=(nvim -p)
        load_project_env "$1"
    fi

    files=()
    for file in "$@"; do
        # Get the full path of the file, using readlink with fallback to realpath
        full_path=$(readlink -f "$file" 2>/dev/null || realpath -m "$file")

        # Extract the directory path
        dir_path=$(dirname "$full_path")

        # Create the directory if it doesn't exist
        mkdir -p "$dir_path"

        # Add the file to the array
        files+=("$full_path")
    done

    # If neovim sees only a single buffer, we will open this files with cwd as a new project.
    if [ -n "$NVIM" ]; then
        nvr -c "if len(getbufinfo({'buflisted':1})) == 1 | cd $(pwd) | endif"
    fi

    "${_opener[@]}" "${files[@]}"
}

function save() {
    if [ -n "$NVIM" ]; then
        if [ -n "$1" ]; then
            nvr -c "cd $(pwd)" \
                -c "split | terminal"\
                -c "SessionsSave! $1" \
                -c "bd!" \
                -c "lua vim.defer_fn(function() vim.cmd('startinsert') end, 100)" \
                -c "lua vim.notify(\"Session saved at $1\", vim.log.levels.OFF, {title= \"Session Management\"})"
        else
            nvr -c "cd $(pwd)" \
                -c "split | terminal"\
                -c "SessionsSave!" \
                -c "bd!" \
                -c "lua vim.defer_fn(function() vim.cmd('startinsert') end, 100)" \
                -c "lua vim.notify(\"Default Session saved\", vim.log.levels.OFF, {title= \"Session Management\"})"
        fi
    else
        echo "Please start a v session: 'v .'"
        return 1
    fi
}

function restore() {
    if [ -n "$NVIM" ]; then
        if [ -n "$1" ]; then
            if [ -f "$1" ]; then
                nvr -c "cd $(pwd)" \
                    -c "SessionsLoad! $1" \
                    -c "winc w" \
                    -c "bd!" \
                    -c "lua vim.defer_fn(function() vim.cmd('startinsert') end, 100)" \
                    -c "lua vim.notify(\"Session loaded from $1\", vim.log.levels.INFO, {title= \"Session Management\"})"
            else
                echo "Error: Specified session file does not exist."
                return 1
            fi
        else
            nvr -c "cd $(pwd)" \
                -c "SessionsLoad!" \
                -c "winc w" \
                -c "bd!" \
                -c "lua vim.defer_fn(function() vim.cmd('startinsert') end, 100)" \
                -c "lua vim.notify(\"Default Session loaded\", vim.log.levels.INFO, {title= \"Session Management\"})"
        fi
    else
        echo "Please start a v session: 'v .'"
        return 1
    fi
}

function session() {
    if [ -n "$NVIM" ]; then
        echo "Error: Cannot start a new Neovim session from within an existing Neovim instance."
        exit 1
    fi

    load_project_env "${1:-.}"

    cmd=(nvim +':terminal')
    if [ $# -eq 0 ]; then
        # cmd=(nvim +':terminal' +':startinsert' +"autocmd User VeryLazy ++once set laststatus=0")
        cmd=(nvim +':terminal' +':startinsert')
    else
        # No laststatus=0 since it creates a buggy behavior
        # cmd=(nvim +":cd $@" +':terminal' +':startinsert' +"autocmd User VeryLazy ++once set laststatus=0")
        cmd=(nvim +":cd $@" +':terminal' +':startinsert')
    fi

    "${cmd[@]}"
}


function reset_venv() {
    if [ -n "$NVIM" ]; then
        nvr -c "lua require('swenv.api').reset_venv()"
    else
        echo "Please start a v session: 'v .' "
        exit 1
    fi
}

function venv() {
    if [ -n "$NVIM" ]; then
        if [ -n "$VIRTUAL_ENV_PROMPT" ]; then
            nvr -c "lua require('swenv.api').set_venv('$VIRTUAL_ENV_PROMPT')"
        elif [ -n "$(cat .venv)" ]; then
            nvr -c "lua require('swenv.api').set_venv('$(cat .venv)')"
        elif command -v poetry &>/dev/null; then
            poetry_venv=$(poetry env list --full-path | grep 'Activated' | awk -F'/' '{print $NF}' | awk '{print $1}')
            if [ -n "$poetry_venv" ]; then
                nvr -c "lua require('swenv.api').set_venv('$poetry_venv')"
            fi
        fi
    else
        echo "Please start a v session: 'v .' "
        exit 1
    fi
}

function vcd() {
    if [ -n "$NVIM" ]; then
        nvr -c "cd $(pwd)"
    else
        echo "Please start a v session: 'v .' "
        exit 1
    fi
}

if [ $# -eq 0 ]; then
    # show_help
    # exit 0
    session "."
fi

if ! command -v nvr >/dev/null; then
    echo "Install neovim-remote"
    exit 1
fi

case "$1" in
    load_project)
        shift
        cmd_load_project "$@"
        ;;
    cd)
        vcd
        ;;
    reset_venv)
        reset_venv
        ;;
    venv)
        venv
        ;;
    hover)
        shift
        hover_vim "$@"
        ;;
    split)
        shift
        svim "$@"
        ;;
    isplit)
        shift
        isvim "$@"
        ;;
    clear)
        if [ -n "$NVIM" ]; then
            nvr -c ":TerminalClear"
        else
            echo "Please start a v session: 'v .' "
            exit 1
        fi
        ;;
    save)
        shift
        save "$@"
        ;;
    restore)
        shift
        restore "$@"
        ;;
    spliting)
        shift
        spliting "$@"
        ;;
    waits)
        shift
        waits "$@"
        ;;
    bg)
        shift
        background "$@"
        ;;
    completions)
        completions
        ;;
    get_root)
        shift
        get_project_root "$@"
        ;;
    -h|--help)
        show_help
        ;;
    -v|--version)
        show_version
        ;;
    *)
        if [ -z "$NVIM" ] && [ -d "$@" ]; then;
            session "$@"
        else
            vim_func "$@"
        fi
        ;;
esac
