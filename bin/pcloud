#!/bin/bash

VERSION="0.0.1"

USERNAME="aemonge"
MOUNT_POINT="/home/$USERNAME/.mounts/cloud"
SECRETS_MOUNT="/home/$USERNAME/.mounts/secret-cloud"
TEMP_SECRETS="/tmp/secrets"

# Define directories to sync
# shellcheck source=/home/aemonge/.pcloud-structure
source "/home/$USERNAME/.pcloud-structure"

# Array to store PIDs of background processes
PIDS=()

function show_help() {
    echo "pcloud - A unified pCloud management script"
    echo ""
    echo "This script provides various operations for managing pCloud, including"
    echo "pulling, pushing, syncing, mounting the pCloud directory, and managing secrets."
    echo ""
    echo "Usage: pcloud [COMMAND]"
    echo ""
    echo "Commands:"
    echo "  pull    Pull data from pCloud to local directories"
    echo "  push    Push data from local directories to pCloud"
    echo "  bysync  Perform a bi-directional sync between pCloud and local directories"
    echo "  sync    Sync data between pCloud and local directories"
    echo "  mount   Mount the pCloud directory"
    echo "  umount  Unmount the pCloud directory"
    echo "  secret [timeout]  Mount secrets directory and unmount after timeout (default: 5 minutes)"
    echo "  -h, --help    Show this help message and exit"
    echo "  -v, --version Show version information and exit"
    echo ""
    echo "For more information, please refer to the script documentation."
}

function show_version() {
    echo "pcloud version $VERSION"
}

function cleanup() {
    # Kill all background processes
    for pid in "${PIDS[@]}"; do
        kill "$pid" 2>/dev/null
    done
    wait 2>/dev/null
    echo "Cleanup completed."
}

function mount_pcloud() {
    echo "Mounting pCloud directory"
    mkdir -p $MOUNT_POINT
    rclone mount pcloud:/ $MOUNT_POINT --daemon --vfs-cache-mode full
    xdg-open "$MOUNT_POINT"
}

function unmount_pcloud() {
    echo "Un-mounting pCloud directory"

    # Try normal unmount first
    fusermount -u "$MOUNT_POINT" || umount "$MOUNT_POINT"

    # If normal unmount fails, try force unmount
    if mountpoint -q "$MOUNT_POINT"; then
        echo "Normal unmount failed. Attempting force unmount..."
        fusermount -uz "$MOUNT_POINT" || umount -f "$MOUNT_POINT"
    fi

    # If it's still mounted, try lazy unmount
    if mountpoint -q "$MOUNT_POINT"; then
        echo "Force unmount failed. Attempting lazy unmount..."
        umount -l "$MOUNT_POINT"
    fi

    # Check if unmount was successful
    if ! mountpoint -q "$MOUNT_POINT"; then
        echo "Successfully unmounted $MOUNT_POINT"
        rmdir "$MOUNT_POINT"
    else
        echo "Failed to unmount $MOUNT_POINT. It may still be in use."
        echo "You might need to close all applications using the mount point and try again."
    fi
}

function sync_operation() {
    local operation=$1
    local max_length=0

    # First pass to determine max length
    for REMOTE_DIR in "${!CLOUD_DIRS[@]}"; do
        LOCAL_DIR=${CLOUD_DIRS[$REMOTE_DIR]}
        if [ "$operation" = "pull" ]; then
            current_length=$((${#REMOTE_DIR} + 15)) # 13 for "Pulling: pcloud:"
        else
            current_length=$((${#LOCAL_DIR} + 11)) # 9 for "Pushing: "
        fi
        if [ $current_length -gt $max_length ]; then
            max_length=$current_length
        fi
    done

    # Add a small buffer to max_length
    max_length=$((max_length + 2))

    # Second pass to perform sync and print aligned output
    for REMOTE_DIR in "${!CLOUD_DIRS[@]}"; do
        LOCAL_DIR=${CLOUD_DIRS[$REMOTE_DIR]}
        if [ "$operation" = "pull" ]; then
            printf "%-*s ➡️  %s\n" $max_length "Pulling: pcloud:$REMOTE_DIR" "$LOCAL_DIR"
            rclone sync -q --check-first "pcloud:$REMOTE_DIR" "$LOCAL_DIR" &
        elif [ "$operation" = "push" ]; then
            printf "%-*s ➡️  %s\n" $max_length "Pushing: $LOCAL_DIR" "pcloud:$REMOTE_DIR"
            rclone sync -q --check-first "$LOCAL_DIR" "pcloud:$REMOTE_DIR" &
        fi
        PIDS+=($!)
    done

    wait
}

function root_sync() {
    echo "Syncing to os directory..."

    perform_sync() {
        local user_home
        local username
        local sync_source
        local sync_target

        if [[ $EUID -eq 0 ]] && [[ -n $SUDO_USER ]]; then
            username="$SUDO_USER"
            user_home="/home/$SUDO_USER"
            sync_source="/"
            sync_target="$user_home/os"
            echo "Running with sudo: syncing from $sync_source to $sync_target (excluding $user_home)"
        else
            username="$(whoami)"
            user_home="$HOME"
            sync_source="$user_home"
            sync_target="$user_home/os/home/$username"
            echo "Running without sudo: syncing from $sync_source to $sync_target"
        fi

        # Function to compare modification times
        compare_times() {
            local source="$1"
            local target="$2"
            local source_time
            local target_time

            source_time=$(stat -c %Y "$source" 2>/dev/null || echo 0)
            target_time=$(stat -c %Y "$target" 2>/dev/null || echo 0)

            if [[ $source_time -gt $target_time ]]; then
                return 0 # Source is newer
            else
                return 1 # Target is newer or same age
            fi
        }

        # Function to sync files
        sync_file() {
            local newer="$1"
            local older="$2"

            if compare_times "$newer" "$older"; then
                [[ ! -f $older ]] && mkdir -p "$(dirname "$older")"
                cp -p "$newer" "$older"
            else
                mkdir -p "$(dirname "$newer")"
                cp -p "$older" "$newer"
            fi
        }

        # Function to find and sync files
        find_and_sync() {
            local search_path="$1"
            local exclude_pattern="$2"

            if command -v fd >/dev/null 2>&1; then
                # Use fd if available
                fd --type f --hidden --follow --exclude "$exclude_pattern" . "$search_path" | while read -r source_file; do
                    relative_path="${source_file#"$search_path"}"
                    target_file="$sync_target$relative_path"
                    sync_file "$source_file" "$target_file"
                done
            else
                # Fallback to find
                find "$search_path" -type f \
                    ! -path "$exclude_pattern" | while read -r source_file; do
                    relative_path="${source_file#"$search_path"}"
                    target_file="$sync_target$relative_path"
                    sync_file "$source_file" "$target_file"
                done
            fi
        }

        if [[ $EUID -eq 0 ]]; then
            # When running with sudo, exclude the user's home directory and some system directories
            exclude_pattern="$user_home/* /proc/* /sys/* /dev/* /run/* /tmp/* /mnt/* /media/* /lost+found"
            find_and_sync "$sync_source" "$exclude_pattern"
        else
            # When running without sudo, only sync the user's home directory
            find_and_sync "$sync_source" ""
        fi
    }

    # Call the function directly, sudo is handled within the function
    perform_sync
}

function start_crypto() {
    local password="$1"
    expect -c "
        spawn pcloudcc -k
        expect \">\"
        send \"startcrypto $password\r\"
        expect \">\"
        send \"quit\r\"
        expect eof
    "
}

function stop_crypto() {
    expect -c "
        spawn pcloudcc -k
        expect \">\"
        send \"stopcrypto\r\"
        expect \">\"
        send \"quit\r\"
        expect eof
    "
}

function mount_secrets() {
    local timeout=${1:-300} # Default timeout: 5 minutes (300 seconds)

    # Check if ~/secrets is not empty
    if [ "$(ls -A $SECRETS_MOUNT)" ]; then
        echo "Moving existing content from $SECRETS_MOUNT to $TEMP_SECRETS"
        mkdir -p $TEMP_SECRETS
        mv $SECRETS_MOUNT/* $TEMP_SECRETS/
    fi

    # Fetch the password from KWallet
    local password
    password=$(kwallet-query -f "Secret Service" -r "pcloud" "kdewallet")

    # Mount secrets
    echo "Mounting secrets directory"
    start_crypto "$password"

    # Try to add content from /tmp/secrets to ~/secrets
    if [ -d "$TEMP_SECRETS" ] && [ "$(ls -A $TEMP_SECRETS)" ]; then
        echo "Syncing content from $TEMP_SECRETS to $SECRETS_MOUNT"
        rsync -av $TEMP_SECRETS/ $SECRETS_MOUNT/
        rm -rf $TEMP_SECRETS
    fi

    echo "Secrets mounted. Will automatically unmount in $timeout seconds."
    xdg-open ~/secrets

    # Set up unmount after timeout
    (
        sleep "$timeout"
        unmount_secrets
    ) &
}

function unmount_secrets() {
    echo "Unmounting secrets directory"
    stop_crypto
    echo "Secrets unmounted"
}

trap cleanup INT TERM EXIT

case "$1" in
pull)
    sync_operation "pull"
    root_sync
    ;;
push)
    root_sync
    sync_operation "push"
    ;;
bysync)
    echo "'bisync' operation is in beta. Please use 'pull' or 'push' instead."
    ;;
sync)
    root_sync
    ;;
mount)
    mount_pcloud
    ;;
umount)
    unmount_pcloud
    ;;
secret)
    mount_secrets "$2"
    ;;
-h | --help)
    show_help
    exit 0
    ;;
-v | --version)
    show_version
    exit 0
    ;;
*)
    show_help
    exit 0
    ;;
esac

echo "Operation completed."
